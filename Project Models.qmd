---
title: "Project Models"
format: html
editor: visual
---

This file is for building and testing machine learning models.

```{r setup}

#Load tools for data cleaning
library(tidyverse)

#Load and preview dataset for analysis
model_data <- read.csv("Transportation_Data_merged.csv")
#view(model_data)

## Use model_data for machine learning models below
```

## Variables + Data Info

```{r}
names(model_data)
dim(model_data)
```

## Model 1 - Linear Regression

### Model 1 - 1

Outcome variable - sustainable_modes_total, Predictor - median age.

For every 1 unit increase in the median age, there is a -.21 decrease of people taking a sustainable mode of transit within a census tract (holding all other variables constant).

```{r}
#all modes combined (pub transit, carpool, walking, biking)
lm.fit <- lm(sustainable_modes_total ~ age_medianE, data = model_data)
summary(lm.fit)
#public transit
lm.fit2 <- lm(transport_mode_public_transitE ~ age_medianE, data = model_data)
summary(lm.fit2)
#carpool
lm.fit3 <- lm(transport_mode_carpoolE ~ age_medianE, data = model_data)
summary(lm.fit3)
#walk
lm.fit4 <- lm(transport_mode_walkE ~ age_medianE, data = model_data)
summary(lm.fit4)
#bike
lm.fit5 <- lm(transport_mode_bikeE ~ age_medianE, data = model_data)
summary(lm.fit5)
```

```{r}
lm_am<- lm(sustainable_modes_total ~ median_monthly_housing_costsE + race_whiteE,
 data = model_data)
summary(lm_am)
```

### Model 1 - 2

Outcome - sustainable_modes_total, Predictor - State.

States with higher prob of taking sustainable modes of transit are Alaska,California, Colorado, Connecticut, DC, Hawaii, Illinois, Maine, Maryland, Massachusetts, Minnesota, Montana, Nevada, New Jersey, New York, Oregon, Pennsylvania, Rhode Island, Vermont, Virginia, Washington, Wyoming.

\*Note - with coefficients greater than 2. Also cool to see that West Virginia, Tennesee, Mississippi, and Arkansas have the smallest coefficients ( \< 1)

```{r}
lm.fit_1 <- lm(sustainable_modes_total ~ State, data = model_data)
summary(lm.fit_1)
```

### Model 1 - 3

For every 1 unit increase in \# of transit stops, we see an .11 increase in the amount of folks taking alternative transit.

```{r}
lm.fit_2 <- lm(sustainable_modes_total ~ Number.of.Transit.Stops, data = model_data)
summary(lm.fit_2)
```

### Model 1 - 4

For every 1 unit increase in \# of intersections, we see a -0.003151 decrease in amount of folks taking sustainable modes of transit.

```{r}
lm.fit_3 <- lm(sustainable_modes_total ~ Number.of.Intersections, data = model_data)
summary(lm.fit_3)
```

### Model 1 - 5

With every 1 unit increase in the Intersections per acre, we see an 11.5 unit increase in amount of people taking sustainable modes of transit.

```{r}
lm.fit_4 <- lm(sustainable_modes_total ~ Intersection.Per.Acre, data = model_data)
summary(lm.fit_4)
```

### Model 1 - 6

For every 1 unit increase in \# stops per acre, we see a 69.3 increase in amount of folks taking sustainable modes of transit.

```{r}
lm.fit_5 <- lm(sustainable_modes_total ~ Stops.Per.Acre, data = model_data)
summary(lm.fit_5)
```

## Model 2 - Multiple Linear Regressions

### Model 2 - 1

Intersections per acre and stops per acre are noteworthy here.

```{r}
mlr.fit <- lm(sustainable_modes_total ~ Number.of.Intersections + Number.of.Transit.Stops + Intersection.Per.Acre + Stops.Per.Acre, data = model_data)
summary(mlr.fit)
plot(mlr.fit)
```

### Model 2 -2

Outcomes - (1) sustainable_modes_total, (2) bike, (3) public transit

Predictors - racial identity

```{r}
mlr.fit2 <- lm(sustainable_modes_total ~ race_whiteE + race_blackE + race_native_americanE + race_pacific_islanderE + race_otherE + race_two_or_moreE + race_hispanicE, data = model_data)
summary(mlr.fit2)
```

```{r}
mlr.fit2_bike <- lm(transport_mode_bikeE ~ race_whiteE + race_blackE + race_native_americanE + race_pacific_islanderE + race_otherE + race_two_or_moreE + race_hispanicE, data = model_data)
summary(mlr.fit2_bike)
```

```{r}
mlr.fit2_pub_transit <- lm(transport_mode_public_transitE ~ race_whiteE + race_blackE + race_native_americanE + race_pacific_islanderE + race_otherE + race_two_or_moreE + race_hispanicE, data = model_data)
summary(mlr.fit2_pub_transit)
```

### Model 2 - 3

This fit takes really long - many counties.

```{r}
mlr.fit_many <- lm(sustainable_modes_total ~ race_whiteE + race_blackE + race_native_americanE + race_pacific_islanderE + race_otherE + race_two_or_moreE + race_hispanicE + pop_density + median_household_incomeE + median_monthly_housing_costsE + Number.of.Intersections + Number.of.Transit.Stops,
 data = model_data)
summary(mlr.fit_many)
```

## Model 3 - Linear Discriminant Analysis

### Model 3 - 1

```{r}

```

## Model X

```{r}

```

## Model X - Unsupervised Clustering

We are looking to potentially find clusters of census tracts to recommend policies to, in an effort to increase their sustainable mode of transportation usage rates. Clusters that are similar to each other in terms of demographics or infrastructure, but have higher rates of non-automobile usage may offer policies that can be emulated by their peers.

The hope is to plot rates of sustainable modes of transport on Y axis, then PC1 on X axis to try and capture as much variance as possible on one axis. A k-means will be performed to hopefully create stratified layers to illustrate "leaps" in rates of non-auto transportation.

```{r}
###Now we try to cluster census tracts based on similarity to each other on the 8 vars we choose bc of importance(). Since my computer cannot handle calculating the cor() of 82,000 obs, we sample 1000 and utilize that.
cluster.df.v2 <- select(model_data, c("GEOID", "pop_density","Intersection.Per.Acre","Stops.Per.Acre","median_monthly_housing_costsE","age_medianE","race_whiteE","race_blackE","race_hispanicE","sustainable_modes_total"))
cluster.matrix.v2 <- na.omit(data.matrix(cluster.df.v2))


set.seed(123)
samp.vct.v2 <- sample(nrow(cluster.matrix.v2), 1000)
samp.matrix.v2 <- cluster.matrix.v2[samp.vct.v2,]

pca.v2 <- prcomp(samp.matrix.v2[,-c(1,10)], scale = T)
pve.v2 <- pca.v2$sdev^2 / sum((pca.v2$sdev)^2)
pve.v2 ## It looks like PC1 is only explaining 34% of the variance, and may not portray the whole picture when it comes to plotting it against sustainable modes of transport. However, we will use PC1 to serve as our X axis in our final plot.

plot(cumsum(pve.v2), xlab = "Principal Component",
ylab = "Cumulative Proportion of Variance Explained", ylim = c(0, 1), type = "b") 
autoplot(pca.v2, label = TRUE) ## Plots to illustrate PCA in action.

set.seed(2)
k2.samp.v2 <- kmeans(samp.matrix.v2[,-c(1,10)], 2, nstart = 50) #61.4%
k3.samp.v2 <- kmeans(samp.matrix.v2[,-c(1,10)], 3, nstart = 50) #82.3%
k4.samp.v2 <- kmeans(samp.matrix.v2[,-c(1,10)], 4, nstart = 50) #89.7%
k5.samp.v2 <- kmeans(samp.matrix.v2[,-c(1,10)], 5, nstart = 50) #93.1%
k6.samp.v2 <- kmeans(samp.matrix.v2[,-c(1,10)], 6, nstart = 50) #95.3%

wss_df <- t(data.frame(61.4,82.3,89.7,93.1,95.3))
k_df<- t(data.frame(2,3,4,5,6))
plot(x= k_df, y = wss_df, ylim = c(0,100), xlab = "K", ylab = "between SS / total SS %")
## Now we look to cluster the sampled census tracts based on our eight vars using our PCA to give our final graph some context as to the demographics and infrastructure in each tract. Using the elbow test, I thought k = 3 would provide a good balance of fit goodness and interpretability. A betweenSS/totalSS of 82.3% indicating a decent fit. 

plot(pca.v2$x[,1],samp.matrix.v2[,10])

k3.plot <- fviz_cluster(k3.samp.v2, data = samp.matrix.v2[, -c(1,10)],
             palette = c("#2E9FDF", "#00AFBB", "#E7B800"), 
             geom = "point",
             ellipse.type = "convex", 
             ggtheme = theme_bw()
             ) ##fviz_cluster from factoextra creates a great k-means cluster plot with accompanying convex hull to make visualization easy.
k3.plot

final.plot.df <- data.frame(samp.matrix.v2,pca.v2$x[,1],k3.samp.v2$cluster) ## Combine the PC1 coordinates and cluster number with the rest of the data to create the final plot
names(final.plot.df)[names(final.plot.df) == 'sustainable_modes_total'] <- 'Rate of Sustainable Travel'
names(final.plot.df)[names(final.plot.df) == 'pca.v2.x...1.'] <- 'PC1 Coordinates'
names(final.plot.df)[names(final.plot.df) == 'k3.samp.v2.cluster'] <- 'Cluster' ## Renaming to make plots cleaner.

final.plot <- ggplot(data = final.plot.df, aes(x = `PC1 Coordinates`, y = `Rate of Sustainable Travel`)) + 
  geom_point(aes(color = as.factor(`Cluster`))) +
  geom_mark_hull(aes(fill = as.factor(`Cluster`)), alpha = 0.1, concavity = 0) +
  guides(color=guide_legend("Cluster"), fill = "none") +
  theme_bw() +
  xlab("PC1 Coordinates (34.1%)") +
  ylab("Rate of Sustainable Travel (%)")

final.plot ## Pretty stratified, although clusters 2 & 3 have plenty of overlap. However, if we look at the means of each cluster based on key variables.

final.plot.df %>%
  group_by(Cluster) %>%
  summarize(mean_sustravel = mean(`Rate of Sustainable Travel`, na.rm = TRUE),
            mean_pdensity = mean(pop_density, na.rm = TRUE),
            mean_idensity = mean(Intersection.Per.Acre, na.rm = TRUE),
            mean_sdensity = mean(Stops.Per.Acre, na.rm = TRUE),
            mean_wpop = mean(race_whiteE, na.rm = TRUE))

## Cluster 1, which has the highest rates of sustainable travel, also are the densest, have the most transit stops per acre, and are the most diverse in terms of population. Cluster 3, looks to be the most auto-dependent, has the lowest population density, and is whiter than the other two clusters. 
```

## Model X - Support Vector Machines

```{r}
#load package for support vector machines
library(e1071)
set.seed(1)

#Generate a histogram of sustainable travel mode usage to select the threshold for classification.
hist(model_data$sustainable_modes_total)

#Adjusting the data for a classification method by turning sustainable_modes_total (percentage) into lables Low (less than 10%) and High (10% or more). Using 10% since the majority are less than that, but a small portion are above.
model_data_svm <- mutate(
  model_data,
  sustainable_modes_class = as.factor(case_when(
    sustainable_modes_total < 10 ~ "low",
    sustainable_modes_total >= 10 ~ "high")
  )
)

model_data_svm <- na.omit(model_data_svm)

train <- sample(dim(model_data_svm)[1],10000)
test <- sample(dim(model_data_svm)[1],10000)

model_data_svm_train <- model_data_svm[train,]
model_data_svm_test <- model_data_svm[test,]


#Create a linear SVC model
tune.out <- tune(svm, 
             sustainable_modes_class ~ race_whiteE + race_blackE + race_native_americanE + race_asianE + race_pacific_islanderE + race_otherE + race_two_or_moreE + race_hispanicE + age_medianE + median_household_incomeE + median_monthly_housing_costsE + Intersection.Per.Acre + Stops.Per.Acre + pop_density,
             data = model_data_svm_train,
             kernel = "linear",
             ranges = list(c(0.001, 0.01, 0.1, 1, 5, 10, 100))
             )

bestmod <- tune.out$best.model
summary(bestmod)

svm_predict <- predict(bestmod, model_data_svm_test)
results <- table(predict = svm_predict, truth = model_data_svm_test$sustainable_modes_class)

svm_linear_test_error <- (results[1,2] + results[2,1])/10000

#Create a polynomial SVC model
tune.out <- tune(svm, 
             sustainable_modes_class ~ race_whiteE + race_blackE + race_native_americanE + race_asianE + race_pacific_islanderE + race_otherE + race_two_or_moreE + race_hispanicE + age_medianE + median_household_incomeE + median_monthly_housing_costsE + Intersection.Per.Acre + Stops.Per.Acre + pop_density,
             data = model_data_svm_train,
             kernel = "polynomial",
             degree = 2,
             ranges = list(c(0.001, 0.01, 0.1, 1, 5, 10, 100))
             )

bestmod <- tune.out$best.model
summary(bestmod)

svm_predict <- predict(bestmod, model_data_svm_test)
results <- table(predict = svm_predict, truth = model_data_svm_test$sustainable_modes_class)

svm_poly_test_error <- (results[1,2] + results[2,1])/10000

#Create a radial SVC model
tune.out <- tune(svm, 
             sustainable_modes_class ~ race_whiteE + race_blackE + race_native_americanE + race_asianE + race_pacific_islanderE + race_otherE + race_two_or_moreE + race_hispanicE + age_medianE + median_household_incomeE + median_monthly_housing_costsE + Intersection.Per.Acre + Stops.Per.Acre + pop_density,
             data = model_data_svm_train,
             kernel = "radial",
             gamma = 1,
             ranges = list(c(0.001, 0.01, 0.1, 1, 5, 10, 100))
             )

bestmod <- tune.out$best.model
summary(bestmod)

svm_predict <- predict(bestmod, model_data_svm_test)
results <- table(predict = svm_predict, truth = model_data_svm_test$sustainable_modes_class)

svm_rad_test_error <- (results[1,2] + results[2,1])/10000



#Compare results
svm_linear_test_error
svm_poly_test_error
svm_rad_test_error

```
